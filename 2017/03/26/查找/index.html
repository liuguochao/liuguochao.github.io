<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="��˵�ü��Բ����ü���">
    <meta name="keyword" content="null">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Moore" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        查找｜Moore&#39;s blog
        
    </title>

    <link rel="canonical" href="http://liuguochao.github.io/2017/03/26/查找/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Moore
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/tags/">tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>查找</h1>
                    
                    <span class="meta">
                         作者 Moore
                        <span>
                          日期 2017-03-26
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#算法"
                           title="算法">算法</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            查找
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <p>查找是最基本的算法之一，在日常的编程中也经常会遇到。因此经常会被拿来作为面试题。今天就总结一下查找的一些基本概念和算法，帮助自己梳理这块东西的复习。</p>
<h4 id="先复习几个概念吧："><a href="#先复习几个概念吧：" class="headerlink" title="先复习几个概念吧："></a>先复习几个概念吧：</h4><ol>
<li><p>查找</p>
<p>查找指的在一组记录组成的集合中寻找主关键字等于给定值的某个记录，或者寻找属性值符合特定条件的某些记录。</p>
<p>如数据库中按照学生的学号查找，查找的</p>
<p>是主关键字，因此最多只能查到一条与之相对应的记录。但是如果按照姓名查找，则可能会查到多条与之相对应的记录。</p>
</li>
<li><p>查找表</p>
<p>查找表是一种数据结构，即如何组织同一类型的记录集合的存储方式使得其更易查找。</p>
<p>查找表常用的操作有：建表、查找、读表元、修改操作(插入、删除 、更新)</p>
<p>读表元指的是读取满足某种条件的记录的各个属性</p>
<p>查找表一般分为<strong>静态查找表</strong>和<strong>动态查找表</strong>。若对查找表的操作不包括修改操作，则称此类查找表为静态查找表；相应的则为动态查找表。</p>
</li>
<li><p>平均查找长度</p>
<p>查找过程中给定值与关键字值比较次数的期望值可以作为衡量一个查找算法优劣的标准，称之为平均查找长度（Average Search Length)，定义为:<br>$$<br>ASL = \sum<em>{i=0}^{n-1}p</em>{i}c<em>{i} \\<br>其中，n是节点个数；p</em>{i}是查找第i个节点的概率，且\sum<em>{i=0}^{n-1}p</em>{i}=1,在每一记录查找概率相等的情况下，p<em>{i}=1/n；\\<br>c</em>{i}是查找第i条记录时关键字值与给定值的比较次数<br>$$<br>其实一般还是都会说查找的时间复杂度是多少。</p>
</li>
</ol>
<h4 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h4><p>顺序查找表底层的存储是用线性表来实现的</p>
<ol>
<li><p>顺序查找</p>
<p>顺序查找就是从表的一端开始，依次将每一个数据元素的关键字值与给定值key进行比较。</p>
<p>这里以数组查找作为例子，介绍各种查找方式的区别，以下方法类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">([] array,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n = array.length;</div><div class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; array[i] != k)&#123;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &lt; n)&#123;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>$$<br>顺序查找的平均查找长度为：(n+1)/2，则其平均时间复杂度为O(n/2)<br>$$</p>
<p>​</p>
<p>当n比较大时查找效率比较低。但是，顺序查找对记录如何存储没有要求，适合频繁的插入和删除工作（链表存储）。</p>
<p>想要提高顺序表的查找速度，一种方法是，在已知各个记录的查找概率不等的情况下，将各个记录按照查找概率的大小排序记录，就可以降低查找的平均查找长度。（这个非常适合新闻网站的查询工作的优化，因为大家关注的都是热点新闻，因此可以将热点新闻记录在前，老旧的新闻记录在后，这样就可以极大地提高查询的效率）；另外一种方法和上一个方法类似，只不过事先不知道哪些记录更可能被查到，可以设定一个规则，类似于新闻点击排行，当一条记录被查询，就与该条记录的前一条记录交换顺序存储位置，这样经过不断的迭代之后，最可能被查到的记录就会排列在前；</p>
</li>
<li><p>二分查找</p>
<p>若静态查找表中的数据记录是按照关键字排好序的，那么此时如果还按照顺序查找的话，查找效率是比较低的。此时可以采用二分的方式查找。其具体步骤如下：</p>
<ol>
<li>将给定的关键字与有序表的中间记录的关键字比较</li>
<li>若相等，则返回其索引；若比它小，则查找其左边表记录；若比它大，则查找其右边表记录</li>
<li>重复1，2直至找到该元素</li>
</ol>
<p>其查找过程其实就是一个二分查找树的搜索过程：</p>
<p><img src="http://www.educity.cn/zk/sjjg/images/134.jpg" alt="二分查找树"></p>
<p>其代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = array.length;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</div><div class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (array[mid] == k)&#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; k)&#123;</div><div class="line">            low = mid+<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            high = mid-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归形式如下</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> k,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> low = begin, high = end;</div><div class="line">    <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (low &gt; high)&#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (array[mid] == k)&#123;</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; k)&#123;</div><div class="line">        <span class="keyword">return</span> binarySearch(array,k,mid+<span class="number">1</span>,high);</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> binarySearch(array,k,low,mid-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>$$<br>二分查找的平均查找长度：AVL=log<em>{2}(n+1)-1，平均时间复杂度则为O(log</em>{2}n)<br>$$</p>
<p>​</p>
<p>但是二分查找必须要求数组是有序的，因此顺序表的存储、插入和删除都非常耗时。所以，基于二分查找的顺序表已经建立，一般不要做大的修改。</p>
</li>
<li><p>分块查找</p>
<p>既然顺序查找、二分查找各有优点，是不是可以将他们俩结合到一起，这就是所谓的分块查找。</p>
<p>其基本思想是：顺序表的可以分为很多块，每块内的元素不一定是有序的，但是块与块之间必须是有序的。例如，第一块内所有元素的关键字值均小于第二块中所有元素的关键字值，相应的，第二块与第三块之间也满足这个关系。</p>
<p>为实现分块查找，还必须建立一个索引表，将每一块中最大（最小）关键字的值和块的索引均存放在这个索引表中。如下图：</p>
<p><img src="http://image.lxway.com/upload/1/c1/1c13615a1fa90dc522b1d6da1eb460a2_thumb.png" alt="分块查找"><br>其代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexBlock</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> startIndex;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">blockSearch</span><span class="params">(<span class="keyword">int</span>[] array,IndexBlock[] indexBlockArray,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = indexBlockArray.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="comment">//二分查找块索引</span></div><div class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</div><div class="line">        <span class="keyword">if</span> (high == <span class="number">0</span>)&#123;</div><div class="line">            i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (indexBlockArray[mid-<span class="number">1</span>].key &lt; k &amp;&amp; k &lt;= indexBlockArray[mid].key)&#123;</div><div class="line">            i = mid;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexBlockArray[mid].key &lt; k)&#123;</div><div class="line">            low = mid+<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexBlockArray[mid-<span class="number">1</span>].key &gt; k)&#123;</div><div class="line">            high = mid-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (low &gt; indexBlockArray.length-<span class="number">1</span>)&#123;</div><div class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//顺序查找</span></div><div class="line">    <span class="keyword">if</span> (i == indexBlockArray.length-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = indexBlockArray[i].startIndex; j &lt; indexBlockArray.length-<span class="number">1</span>; j++)&#123;</div><div class="line">            <span class="keyword">if</span> (indexBlockArray[j] == k)&#123;</div><div class="line">                <span class="keyword">return</span> j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = indexBlockArray[i].startIndex; </div><div class="line">             j &lt; indexBlockArray[i+<span class="number">1</span>].startIndex; j++)&#123;</div><div class="line">          <span class="keyword">if</span> (indexBlockArray[j] == k)&#123;</div><div class="line">                <span class="keyword">return</span> j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>$$<br>分块查找的平均才查找长度为：ASL=L<em>{b}+L</em>{s}\\<br>其中，L<em>{b}为查找索引表确定记录所在块的平均查找长度，L</em>{s}为在该块中超找到该条记录的平均查找长度<br>$$</p>
</li>
</ol>
<h4 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h4><p>动态查找表的底层存储是用树形结构实现的</p>
<ol>
<li><p>二叉排序树</p>
<p>二叉排序树是一种树形存储结构，如下图所示：</p>
<p><img src="http://pic002.cnblogs.com/images/2012/457289/2012110918051618.jpg" alt="二叉排序树"><br>它具有以下性质：</p>
<ol>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ol>
<p>二叉树的查找过程和二分查找比较相似，其步骤可以总结如下：</p>
<ol>
<li>若给定值k等于根节点的关键字值，则查找成功，结束查找。否则转入步骤2</li>
<li>若给定值k小于根节点的关键字值，则继续在其非空左子树上进行查找，否则转入步骤3</li>
<li>若给定值k大于根节点的关键字值，则继续在其非空右子树上进行查找</li>
</ol>
<p>相应的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//查找到返回1，未查到返回-1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchTreeSearch</span><span class="params">(BinSearchTreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root.getData() == k)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.getData() &lt; k)&#123;</div><div class="line">        <span class="keyword">return</span> binarySearchTreeSearch(root.getLeftChild(),k);</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> binarySearchTreeSearch(root.getRightChild(),k);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>$$<br>二叉排序树的平均查找长度为：AVL=log<em>{2}n+1\\<br>因此其平均时间复杂度为O(log</em>{2}n)<br>$$</p>
<p>二叉排序树的查找比较容易实现，但是其插入和删除操作却比较难，下面给出其代码：</p>
<ol>
<li><p>插入</p>
<p>假设带插入节点的关键字值为k，分两种情况：</p>
<ul>
<li>若插入的关键字k在树中存在，则不用插入</li>
<li>若不存在，则将其作为叶子节点插入到树中</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//插入</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearchTreeInsert</span><span class="params">(BinSearchTreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</div><div class="line">        root = <span class="keyword">new</span> BinSearchTreeNode(k);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        BinSearchTreeNode current = root;</div><div class="line">        BinSearchTreeNode parent = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>)&#123;</div><div class="line">            parent = current;</div><div class="line">            <span class="keyword">if</span> (current.getData() == k)&#123;</div><div class="line">                System.out.println(<span class="string">"k已经存在，不用插入"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.getData() &gt; k)&#123;</div><div class="line">                current = current.getLeftChild();</div><div class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)&#123;</div><div class="line">                    current = <span class="keyword">new</span> BinSearchTreeNode(k);</div><div class="line">                    parent.setLeftChild(current);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                current = current.getRightChild();</div><div class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)&#123;</div><div class="line">                    current = <span class="keyword">new</span> BinSearchTreeNode(k);</div><div class="line">                    parent.setLeftChild(current);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//删除</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearchTreeDelete</span><span class="params">(BinSearchTree root,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    BinSearchTree current = root;</div><div class="line">    BinSearchTree parent = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>)&#123;</div><div class="line">        System.out.println(<span class="string">"空树，无法删除"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span> (current.getData() == k)&#123;</div><div class="line">                <span class="keyword">return</span> binarySearchTreeDelete(current,parent,isLeft);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.getData() &gt; k)&#123;</div><div class="line">                isLeftChild = <span class="keyword">true</span>;</div><div class="line">                parent = current;</div><div class="line">                current = current.getLeftChild();</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                isLeftChild = <span class="keyword">false</span>;</div><div class="line">                parent = current;</div><div class="line">                current = current.getRightChild();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"未找到关键字值等于k的节点，无法删除"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">binarySearchTreeDelete</span><span class="params">(BinSearchNode current,BinsearchNode parent,isLeft)</span></span>&#123;</div><div class="line">    <span class="comment">//既没有左子树，也没有左子树，即该节点为叶子节点,直接删除即可</span></div><div class="line">    <span class="keyword">if</span> (current.getRightChild() == <span class="keyword">null</span> &amp;&amp; current.getRightChild() == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>)&#123;</div><div class="line">            current = <span class="keyword">null</span>;<span class="comment">//删除根节点</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeft)&#123;</div><div class="line">            parent.setLeftChild(<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            parent.setRightChild(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.getRightChild() == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//只有左子树，没有右子树，直接将其左子树的根节点替代被删除节点的位置即可</span></div><div class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>)&#123;</div><div class="line">            current = current.getLeftChild();<span class="comment">//删除根节点</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeft)&#123;</div><div class="line">            parent.setLeftChild(current.getLeftChild());</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            parent.setRightChild(current.getLeftChild());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getLeftChild() == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//只有右子树，没有左子树，直接将其右子树的根节点替代被删除节点的位置即可</span></div><div class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>)&#123;</div><div class="line">            current = current.getRightChild();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeft)&#123;</div><div class="line">            parent.setLeftChild(current.getRightChild());</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            parent.setRightChild(current.getRightChild());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//左右子树都存在</span></div><div class="line">        BinSearchNode needNode = getNeedNode(current);</div><div class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>)&#123;</div><div class="line">            current = needNode;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</div><div class="line">            parent.setLeftChild(needNode);</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            parent.setRightChild(needNode);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (needNode != current.getRightChild())&#123;</div><div class="line">            needNode.setRightChild(current.getRightChild());</div><div class="line">        &#125;</div><div class="line">        needNode.setLeftchild(current.getLeftChild());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> BinSearchNode <span class="title">getNeedNode</span><span class="params">(BinSearchNode delNode)</span> </span>&#123;   </div><div class="line">        BinSearchNode current = delNode.getRightChild();      </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (current.getLeftChild() != <span class="keyword">null</span>)&#123;</div><div class="line">                current = current.getLeftChild();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> current;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​</p>
<p>如果二叉树是平衡的，那么n个节点的二叉排序树的查找是最优的；但是如果二叉树是严重不平衡的话，其查找时间复杂度可以为O(n)，如下图的二叉排序树：</p>
<p><img src="http://hiphotos.baidu.com/juds/pic/item/f0427ecfdc820337f8dc61ab.jpg" alt="二叉排序树比较"></p>
</li>
<li><p>平衡二叉树</p>
<p>二叉排序树的性能和树的形态有很大的关系。因此，在构造二叉排序树的过程中，当出现左右子树不平衡时，应该对其进行调整，这样才能保证二叉排序树的最优查找性能，即所谓的平衡二叉树。</p>
<p>平衡二叉树（Balanced Binary Tree）定义：它是一棵空树，或是具有以下性质的一棵二叉树，即左子树和右子树都是平衡二叉树，且左右子树的深度之差不超过1。平衡二叉树也叫AVL树。</p>
</li>
<li><p>B_树和B+树</p>
<p>虽然平衡二叉树最好和最差的查找效率都为O(log(n))，但是当数据量非常大的时候，查找起来效率还是很低。较大规模的数据记录一般都存放外存中，对于磁盘的IO操作是非常费时的，因此应该尽可能地降低磁盘IO的次数，此时可以将平衡二叉树拓展为平衡“多叉”树，即所谓的平衡多路查找树。</p>
<p>例如：若将存放在外存中的10亿条记录组织为平衡二叉树，则每次访问平均需要30次外存访问，而如果采用256阶(256^4 &gt; 10亿)的B_树组织，每次访问记录仅需访问4次（256^4 &gt;10亿）即可。</p>
<ol>
<li><p>B_树</p>
<p>B_树是一种平衡的多路查找树，一棵m阶（m&gt;=3）阶的B树，或为空树，或者是具有以下性质的树：</p>
<ul>
<li><p>树种每个节点至多有m棵子树</p>
</li>
<li><p>若根节点不是叶子节点，则至少有2棵子树</p>
</li>
<li><p>所有的非终端节点中包含下列信息：<br>$$<br>(n,p<em>{0},k</em>{1},p<em>{1},k</em>{2},p<em>{2},…,k</em>{n},p<em>{n})\\<br>其中，n为关键字的个数，k</em>{i}为关键字，且满足k<em>{i}&lt;k</em>{i+1}；p<em>{j}为指向子树根节点的指针，且p</em>{j}所指子树的\\<br>关键字值均小于k<em>{j+1}，p</em>{n}所指子树中所有节点的关键字值均大于k_{n}.<br>$$</p>
</li>
<li><p>除根节点之外所有的非终端节点至少有[m/2]棵子树，也即每个非根节点至少应有[m/2]-1个关键字</p>
</li>
<li><p>所有的叶子节点都出现在同一层次上，并且不带任何信息</p>
</li>
</ul>
<p><img src="http://kugames.youku.com/dtt/wp-content/uploads/2015/11/4.jpg" alt="B_树"></p>
</li>
<li><p>B+树</p>
<p>B_树和B+树都是B树的一种实现，一棵m阶的B+树相比B-树差异在于：</p>
<ul>
<li>在B-树中，每个节点有n个关键字和n+1棵子树；而在B+树中，每一个节点有n个关键字和n棵子树，即每一关键字对应一棵子树</li>
<li>在B-树中，每个节点关键字的个数n的取值为[m/2-1]&lt;=n&lt;=[m-1]；而在B+树中，n的取值为[m/2]&lt;=n&lt;=m</li>
<li>B+树中所有非叶子节点仅起到索引的作用，即节点中的每一索引项只含有对应子树的最大关键字和指向该子树的指针，不包含该关键字对应记录的存储地址</li>
</ul>
<p><img src="http://kugames.youku.com/dtt/wp-content/uploads/2015/11/5.jpg" alt="B+树"><br>相比于B-树，B+树更适合于文件索引系统</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3></li>
</ol>
</li>
</ol>
<p>线性表、二叉排序树、平衡二叉树、B_树等数据结构，数据元素存储在内存空间的位置与数据元素的关键字之间不存在直接的确定关系，因此其查找的时间复杂度不会小于O(log(n))。</p>
<p>而哈希表则建立了数据元素关键字与存储位置之间的相关关系。其基本思想为：</p>
<ol>
<li>以关键字为自变量，通过一定的函数关系（hash函数），计算出对应的函数值(hash值)，以这个值作为数据元素的存储地址。</li>
<li>查找时根据待查找的关键字采用同样的hash函数计算出相应的存储地址，直接利用存储地址就可以快速取出元素，其查找效率接近于O(1)。</li>
</ol>
<p>哈希表查找的方式需要解决好以下两个问题：</p>
<ol>
<li>hash函数应尽可能简单，以便减少hash计算的时间复杂度</li>
<li>hash函数应使得关键字映射后的地址值分布尽量均匀，以避免存储空间的浪费</li>
</ol>
<h4 id="常用的hash函数"><a href="#常用的hash函数" class="headerlink" title="常用的hash函数"></a>常用的hash函数</h4><p>hash函数非常多，这里仅选择几个我认为比较常用的</p>
<ol>
<li><p>取模法<br>$$<br>H(key)=key\ \%\ p<br>$$<br>其中p的选取非常重要，若p的选择不当，会造成严重的hash值冲突。一般若地址值个数为m，则p选择为小于或等于m的某个最大素数。如下表：</p>
<p>| 哈希表长度（m)  |  8   |  16  |  32  |  64  | 128  | 256  | 512  |<br>| ——— | :–: | :–: | :–: | :–: | :–: | :–: | :–: |<br>| <strong>模数(p)</strong> |  7   |  13  |  31  |  61  | 127  | 251  | 503  |</p>
<p>我们知道在java中想要比较两个对象，一般需要重写hashCode()方法和equals()方法，例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> studentNum;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</div><div class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line">		result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</div><div class="line">		result = prime * result + studentNum;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//省略equals</span></div><div class="line">	....</div><div class="line">&#125;</div><div class="line"><span class="comment">//java自带的hashcode()方法如下：</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = hash;</div><div class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">char</span> val[] = value;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</div><div class="line">                h = <span class="number">31</span> * h + val[i];</div><div class="line">            &#125;</div><div class="line">            hash = h;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面我们发现p的取值就是31，网上的很多解释都是说为了简化计算等，其实就是hash()函数取模数的一种规范而已，虽然这里没有用取模法计算hash值，但是以素数作为基底，能够保证得到的结果唯一性的可能性更大。</p>
</li>
<li><p>平方取中法</p>
<p><strong>平方取中法</strong>(Middle-square method)是个产生<a href="http://baike.baidu.com/item/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="external">伪随机数</a>的方法，由冯·诺伊曼在<a href="http://baike.baidu.com/item/1946%E5%B9%B4" target="_blank" rel="external">1946年</a>提出（百科），其实目的也是尽可能使得hash之后的值分布分散。</p>
<p>这里是取关键字平方的中间几位作为hash值，具体选取多少需要视实际情况而定。一般适用于关键字每一位取值不够分散后者分散的位数小于hash地址所需要的位数的情况。现在基本上已经淘汰。</p>
</li>
<li><p>折叠法</p>
<p>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址，常用的有移位叠加法和间界叠加法。</p>
<p>具体请百度，实在不想写了。。。。</p>
<p>​</p>
</li>
</ol>

                <hr>
                
                <!-- 多说 Share start -->
                <div class="ds-share"
                     style="text-align: right"
                     data-thread-key="2017/03/26/查找/"
                     data-title="查找"
                     data-url="http://liuguochao.github.io/2017/03/26/查找/"
                     data-images=""
                     data-content="查找是最基本的算法之一，在日常的编程中也经常会遇到。因此经常会被拿来作为面试题。今天就总结一下... | Moore&#39;s blog ">
                    <div class="ds-share-inline">
                        <ul class="ds-share-icons-16">
                            <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                            <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                            <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                            <li><a class="ds-douban flat" href="javascript:void(0);" data-service="douban">豆瓣</a></li>
                        </ul>
                        <div class="ds-share-icons-more">
                        </div>
                    </div>
                    <hr>
                </div>
                <!-- 多说 Share end-->
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/03/28/字符串匹配算法/字符串匹配算法/" data-toggle="tooltip" data-placement="top"
                           title="字符串匹配算法">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/03/21/二叉树/二叉树/" data-toggle="tooltip" data-placement="top"
                           title="二叉树">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                         data-thread-key="2017/03/26/查找/"
                         data-title="查找"
                         data-url="http://liuguochao.github.io/2017/03/26/查找/">
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#先复习几个概念吧："><span class="toc-text">先复习几个概念吧：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态查找表"><span class="toc-text">静态查找表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态查找表"><span class="toc-text">动态查找表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表"><span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用的hash函数"><span class="toc-text">常用的hash函数</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#算法"
                           title="算法">算法</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="http://rosen.xyz/">Roxen</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User by Hux
    var _user = 'liuguochao';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user};
    (function () {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->





<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/liu-guo-chao-86">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/liuliuguochao">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/liuguochao">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Moore 2017
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://liuguochao.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','null','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="null">
</body>

</html>
