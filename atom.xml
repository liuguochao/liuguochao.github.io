<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moore</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuguochao.github.io/"/>
  <updated>2017-03-20T12:42:03.755Z</updated>
  <id>http://liuguochao.github.io/</id>
  
  <author>
    <name>Moore</name>
    <email>guochao_liu@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java内存分区</title>
    <link href="http://liuguochao.github.io/2017/03/20/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
    <id>http://liuguochao.github.io/2017/03/20/JVM内存划分/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T12:42:03.755Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了《深入理解java虚拟机》这本书，现总结一下。该篇介绍java虚拟机的内存划分：</p>
<p>上图：</p>
<p><img src="./region.jpeg" alt="region"></p>
<p>大多数人将JVM的内存划分为堆和栈，这是有道理的，但是不是特别准确。准确的说JVM的内存可以划分为5个区域。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>java堆是jvm内存管理中最大的一块，线程共享。在jvm启动的时候创建。此区域唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>由于现在的收集器基本都采用分代收集算法，所以java堆还可以细分为新生代和老年代，新生代中垃圾回收算法为复制算法，老年代中采用的为标记-清除算法</p>
<p>新生代还可以细分为Eden区和Survivor区，对象优先在Eden区域分配，大对象会直接进入老年代，长期存活的对象会进入老年代，这里的长期存活是根据新生代中的对象年龄阈值来定义的，对象刚分配到新生代的时候年龄为1，每进行一次GC对象的年龄会加1，HotSpot中默认的阈值是15，也就是说对象年龄达到15岁的时候会被分配到老年代，这个值是可以通过参数配置的。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区又被称为永久代，线程共享，是用来存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区为堆的一个逻辑部分，但是在JDK1.7的HotSpot中已经将方法区中的字符串常量池移出，部分资料显示JDK1.8已经去除了方法区（不确定）。不过已经可以猜测此区域将会被本地内存逐步取代。</p>
<p>这个区域很少进行垃圾回收，回收目标主要是针对常量池的回收和对类型的卸载，回收的条件相当苛刻</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈是线程私有的，它的生命周期与线程相同。JVM栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<strong>每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</strong>。</p>
<p><strong>局部变量表中存放了编译期可知的各种基本数据类型、对象的引用类型。局部变量表中需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</strong>。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈和JVM栈非常相似，它们之间的区别不过是jvm栈是为执行java方法服务，而本地方法栈是为jvm使用到对的本地方法服务。HotSpot虚拟机中直接把本地方法栈和JVM栈合二为一了。例如在java中调用Python书写的程序，就需要使用本地方法栈</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，线程私有。所以每个线程内部都维护了一个程序计数器。它可以看作是当前线程所执行的字节码的行号指示器。在jvm的概念模型里，字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的jvm字节码指令的地址；如果正在执行的是本地方法，这个计数器值则为空。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了《深入理解java虚拟机》这本书，现总结一下。该篇介绍java虚拟机的内存划分：&lt;/p&gt;
&lt;p&gt;上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./region.jpeg&quot; alt=&quot;region&quot;&gt;&lt;/p&gt;
&lt;p&gt;大多数人将JVM的内存划分为堆和栈，这是有道理的，但是不
    
    </summary>
    
    
      <category term="JVM" scheme="http://liuguochao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://liuguochao.github.io/2017/03/20/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://liuguochao.github.io/2017/03/20/JVM垃圾回收机制/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T11:36:26.375Z</updated>
    
    <content type="html"><![CDATA[<p>Java的垃圾回收（Garbage Collection, GC）机制一直面试最常见的问题，谈到垃圾回收，首先应该想到的就是三个大问题：</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>这里的GC算法主要指的是堆和方法区的GC算法，因为程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，它们内存区域应该分配多少内存在编译期间就已知，因此这3个区域的内存分配和回收都具备确定性，不需要复杂的GC算法，而堆和方法区直到程序运行时才能最终确定需要创建多少对象，因此内存的分配和回收都是动态的，所以需要设计比较高效的GC算法。</p>
<h4 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h4><p>在堆里面存放着Java中几乎所有对象的实例，垃圾收集器在对堆中对象进行回收之前，需要首先判断哪些对象还<strong>存活</strong>着，哪些已经<strong>死去</strong>。</p>
<ol>
<li><p><strong>引用计数法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给对象中添加一个引用计数器，每当有一个地方引用它时，计数值就加1；档引用失效时，计数值就减1；任何时刻计数器为0的对象就是不可能再被使用的</div></pre></td></tr></table></figure>
<p>这种方法简单高效，但是主流的Java虚拟机中普遍没有采用这种方法，因为他无法解决<strong>对象间相互循环引用的问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ListNode a=<span class="keyword">new</span> ListNode();</div><div class="line">ListNode b=<span class="keyword">new</span> ListNode();</div><div class="line">a.next=b;</div><div class="line">b.next=a;</div><div class="line">a=<span class="keyword">null</span>;</div><div class="line">b=<span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>在上面的代码中，对象a、b的next相互指向对方，除此之外再没有任何引用，实际上这两个对象已经不可能再被访问，然而如果采用引用计数法，两个对象的计数都不为0，因为他们互相指向对方，导致垃圾回收器无法回收他们。</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">这个算法的基本思想就是通过一系列成为”GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，档一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</div></pre></td></tr></table></figure>
<p><img src="./road.png" alt="road"></p>
<p>例如上图所示，对象object5、object6、object7虽然互相有关联，但是他们到GC Roots是不可达的，所以他们将会被判定为是可回收的对象。</p>
<p>在主流的商用程序语言的主流实现中，都是采用可达性分析算法来判定对象是否存活的。</p>
<p>Java中，可以作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地表量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<p>一个对象并不是被判定为不可达，就一定会被回收，因为它还会经历一个<strong>两次标记的过程</strong>：</p>
<p>第一次：判断为不可达后，会进行第一次标记，并进行筛选以判断该对象是否执行finalize()方法，筛选的条件是：</p>
<ul>
<li>对象没有覆盖finalize()方法</li>
<li>该对象的finalize()方法已经被虚拟机调用过</li>
</ul>
<p>这两种情况下，都不会再执行finalize()方法。</p>
</li>
</ol>
<h4 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h4><p>比较常见的说法就是虚拟机会在系统空闲的时候进行垃圾回收，但这不够准确。其实上面时候进行回收确实是系统自身决定的，代码不可控制，System.gc()方法也仅仅是建议，但不一定会保证一定发生。</p>
<p>回答这个问题，一定要结合JVM堆内存的划分来回答，现在来回想一下堆内存的划分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java堆可以细分为新生代和老年代,新生代还可以细分为Eden区和Survivor区，对象优先在Eden区域分配，大对象会直接进入老年代，长期存活的对象会进入老年代</div></pre></td></tr></table></figure>
<p>不同区域的垃圾回收频率和算法均不一样，因此，可以这样回答这个问题：</p>
<p>Java的GC分为两种：新生代GC和老年代GC：</p>
<ul>
<li><strong>新生代GC(Minor GC)</strong>：指发生在新生代的垃圾收集动作，因为这里面对象都是“朝生夕死”的，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li><strong>老年代GC(Major GC/Full GC)</strong>：指发生在老年代的GC，出现Major GC经常会伴随至少一次的Minor GC(但不是绝对的)。</li>
</ul>
<ol>
<li><h5 id="新生代GC"><a href="#新生代GC" class="headerlink" title="新生代GC"></a>新生代GC</h5><h5 id="Eden区与Minor-GC"><a href="#Eden区与Minor-GC" class="headerlink" title="Eden区与Minor GC"></a>Eden区与Minor GC</h5><p>大多数情况下，对象会在新生代的Eden区分配，当Eden没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p>
</li>
<li><h5 id="老年代GC"><a href="#老年代GC" class="headerlink" title="老年代GC"></a>老年代GC</h5><p>执行Full GC由于消耗的资源比较大，所以会比较谨慎，在进行之前需要两次判断。</p>
<ul>
<li><p><strong>第一次判断：</strong>在发生Full GC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC可以安全执行，没有必要执行Full GC。</p>
<p>但是，如果不成立，那么就<strong>可能</strong>有必要执行一次Full GC以清除老年代的垃圾。</p>
<p>为什么说可能呢？因为虽然现在老年代无法容纳所有新生代的内存，但是大部分情况下新生代的内存都会被清理很多的，所以万一新生代需要进入老年代的内存只占其中一小部分呢，那么就不用执行Full GC了啊，当然，这在运行时无法确定，需要冒险。</p>
</li>
<li><p><strong>第二次判断:</strong>  有一个参数<strong>HandlePromotionFailure</strong>的作用就是设置是不是要冒险，如果设置为可以冒险，那么会那么会继续检查老年代最大可用的连续空间，判断它是否大于历次晋升到老年代对象的平均大小，也就是大致评估一下这次冒险的成功率，如果如果大于，说明冒险的成功率比较高，那么就不会执行Full GC。</p>
<p>如果设置为不可以冒险，或者冒险的成功率比较低，那么久会老老实实的执行Full GC</p>
<p>最后，如果冒险失败，那么最后还是会进行Full GC</p>
</li>
</ul>
<p>​</p>
<p>可以看出，虚拟机执行Full GC是非常谨慎的，不到万不得已绝不执行，就是因为这个过程非常浪费资源，Full GC的速度一般会比Minor GC慢10倍以上</p>
</li>
</ol>
<h4 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h4><p>为了提高垃圾回收的效率，JVM细分为新生代和老年代，对不同的内存区域选用不同的GC算法，即所谓的分代收集算法。</p>
<ol>
<li><p><strong>新生代GC算法</strong></p>
<ul>
<li><p>标记清除算法</p>
<p>分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p><img src="./bjqc.png" alt="bjqc"></p>
<p>该算法的缺点是效率不高并且会产生不连续的内存碎片，所以GC基本不采用这种算法。</p>
</li>
<li><p>复制算法</p>
<p>把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。</p>
<p><img src="./fz.png" alt="fz"></p>
</li>
</ul>
<p>​    优点：实现简单，运行高效</p>
<p>​    缺点：会浪费一块内存</p>
<p>然而，为什么现在的虚拟机都是采用这种复制算法来回收新生代的垃圾呢，因为新生代的对象中，大部分都是“朝生夕死”的。所以，并不需要按照1：1的（理论）比例来分配，而是将新生代继续划分为Eden区域和Survivor区域，划分比例为8:1:1（默认，其实可以调），如下图：</p>
<p><img src="./eden_survivor.png" alt="eden_survivor"></p>
<p>​</p>
<p>其中，Survivor区域被划分为Survivor1和Survivor2，也成为from区域和to区域。</p>
<p>当Eden区满执行GC的时候，将 Eden 区和 Survivor区中还存活着的对象一次性地复制到另一块Survivor(to)空间上，最后清理掉Eden和过程用过的Survivor(from)的空间。然后from和to对调，下次继续这样执行。</p>
<p>这样每次新生代中可用的内存空间是整个新生代的90%(Eden和一个Survivor， 80%+10%)，只用10%的内存被“浪费”。</p>
</li>
<li><p><strong>老年代GC算法</strong></p>
<p>老年代的对象存活时间比较长，对象存活率也比较高，如果老年代也采用复制算法进行老年代的GC，则要进行较多的复制操作，效率会变低。所以在老年代一般不采用这个算法。</p>
<p>根据老年代的特点，人们提出了“标记-整理”算法。过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="./bzzl.png" alt="bzzl"></p>
</li>
</ol>
<p>解决完这垃圾回收的3个基本问题，就可以设计相应的垃圾收集器了，下面罗列一下JVM常用的垃圾收集器：</p>
<ul>
<li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li>
<li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li>
<li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li>
<li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li>
<li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li>
<li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li>
<li>G1(Garbage-First)收集器，当今最优秀的垃圾收集器，JDK1.7以上默认的垃圾收集器，面向服务端。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的垃圾回收（Garbage Collection, GC）机制一直面试最常见的问题，谈到垃圾回收，首先应该想到的就是三个大问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些内存需要回收&lt;/li&gt;
&lt;li&gt;什么时候回收&lt;/li&gt;
&lt;li&gt;如何回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里
    
    </summary>
    
    
      <category term="JVM" scheme="http://liuguochao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://liuguochao.github.io/2017/03/20/Java%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuguochao.github.io/2017/03/20/Java命令模式/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T12:35:58.463Z</updated>
    
    <content type="html"><![CDATA[<p>假设这样一个场景，领导派给你一个任务，你要完成这个任务。作为领导他并不需要关心任务具体的执行细节，只需要发出命令即可，这样就最大限度地减轻了领导的负担。这就是命令模式——解耦请求者与执行者。</p>
<p>现在考虑一个现实应用：顾客A来到餐馆点一碗面（发出请求） -&gt; 柜台服务员记录下来（创建命令） -&gt; 服务员把小票扔给厨房 -&gt; 厨师C很快做好了一碗面（请求被执行）</p>
<p>顾客不知道将由谁来做这碗面，柜台服务员也不知道，厨师不知道是谁点了这碗面，只知道做完面就可以休息了</p>
<p>首先定义一个命令接口，使得所有的具体命令都实现该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//来一碗面条</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoodlesCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Chef chef;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoodlesCommand</span><span class="params">()</span></span>&#123;</div><div class="line">        chef = <span class="keyword">new</span> NoodlesChef();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>&#123;</div><div class="line">        chef.cook();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//来一张饼</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Chef chef;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PieCommand</span><span class="params">()</span></span>&#123;</div><div class="line">        chef = <span class="keyword">new</span> PieChef();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>&#123;</div><div class="line">        chef.cook();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再定义一个抽象的执行者，所有的执行者均继承于该执行者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Chef</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//做面条的厨师</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoodlesChef</span> <span class="keyword">extends</span> <span class="title">Chef</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"做好了一碗面条"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//做饼的厨师</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieChef</span> <span class="keyword">extends</span> <span class="title">Chef</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"做好了一张饼"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Command Pattern餐馆开张。。"</span>);</div><div class="line">        System.out.println(<span class="string">"第一位客户X先生"</span>);</div><div class="line">        System.out.println(<span class="string">"X先生：你好，我需要一碗面，我饿极了"</span>);</div><div class="line">        NoodlesCommand nCmd = <span class="keyword">new</span> NoodlesCommand();<span class="comment">//请求者不知道到底是谁做的面条，只是下达命令</span></div><div class="line">        System.out.println(<span class="string">"柜台服务员：好的，我已经记下了，马上就好"</span>);</div><div class="line">        System.out.println(<span class="string">"柜台服务员：厨房~~,接单"</span>);</div><div class="line">        nCmd.execute();<span class="comment">//服务员控制执行的具体时间</span></div><div class="line">        System.out.println(<span class="string">"X先生：真快啊！"</span>);</div><div class="line">         </div><div class="line">        System.out.println();</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"第二位客户XX先生"</span>);</div><div class="line">        System.out.println(<span class="string">"XX先生：你好，我需要一块饼，20分钟后来取"</span>);</div><div class="line">        PieCommand pCmd = <span class="keyword">new</span> PieCommand();</div><div class="line">        System.out.println(<span class="string">"柜台服务员：好的，我已经记下了"</span>);</div><div class="line">        System.out.println(<span class="string">"15分钟后"</span>);</div><div class="line">        System.out.println(<span class="string">"柜台服务员：厨房~~,接单"</span>);</div><div class="line">        pCmd.execute();</div><div class="line">        System.out.println(<span class="string">"XX先生：真准时啊！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>假如现在需求改变，顾客下了一个单，服务员将单子给厨房的某个厨师，厨师吩咐底下的小工去切菜，切肉，小工发现菜不够了，打电话给小贩送菜……，这样多级命令的调用——宏命令（多条命令顺序执行）怎么实现？</p>
<p>实现的话，仅需在原始的具体Command的excute方法中调用下一条具体Command的excute方法，下一条具体Command的excute方法，再调用下下一条具体Command的excute方法，碰到具体的执行者，就调用执行者相关的执行方法。</p>
</li>
<li><p>加入现在需求又发生改变，假如来了很多顾客，点了很多份餐点，过了一会儿有几个顾客等不及了需要撤销，我们如何实现？</p>
<p>这个也比较容易实现，只需在Command接口中添加一个undo()方法就行了。</p>
</li>
<li><p>加入现在需求有改变，这次不是餐馆，比如你要做一个文本编辑器，用户发出了一系列的命令，完成了一些操作，后来发现操作有问题，想要撤销操作N次，怎么支持多步顺序撤销？</p>
<p>这次我们需要维护一个命令表，且支持“后入先出”的原则，因此我们可以用一个栈来存放相应的指令，如果想要撤销指令的话，就从栈中弹出相应的指令即可。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设这样一个场景，领导派给你一个任务，你要完成这个任务。作为领导他并不需要关心任务具体的执行细节，只需要发出命令即可，这样就最大限度地减轻了领导的负担。这就是命令模式——解耦请求者与执行者。&lt;/p&gt;
&lt;p&gt;现在考虑一个现实应用：顾客A来到餐馆点一碗面（发出请求） -&amp;gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://liuguochao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://liuguochao.github.io/2017/03/20/Java%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuguochao.github.io/2017/03/20/Java策略模式/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T11:39:19.538Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式用一句话概括就是<strong>“面向接口编程”</strong>，将频繁发生变化的方法封装为接口，实现抽象方法与具体对象的解耦，增加了程序的灵活性和可扩展性。</p>
<p>借用《Head First 设计模式》这本书的例子，说明策略模式提出的背景：</p>
<p>你是某游戏公司的软件工程师Joe，现在有个打鸭子的游戏要做，因为鸭子种类很多（假如确实非常多，包括假的鸭子），你这样定义鸭子类：</p>
<p><img src="http://img.blog.csdn.net/20150321104828964?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjMwOTI2Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//定义鸭子叫</span></div><div class="line">        System.out.println(<span class="string">"quack!quack!"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//定义鸭子游泳</span></div><div class="line">        System.out.println(<span class="string">"duck swiming!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//定义鸭子的外观，因为不同鸭子的外观不同，因此定义为抽象方法，让子类去重写</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">diplay</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//定义几个子类</span></div><div class="line"><span class="keyword">public</span> MallardDuck extends Duck&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">diplay</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是绿头鸭！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> RedHeadDuck extends Duck&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是红头鸭！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">.......</div></pre></td></tr></table></figure>
<p>当你做好了这些类以后，产品经理有一天对你说，现在要为每种鸭子添加飞的功能。你觉得作为一个OO软件开发的人来说太easy了，于是你用继承在Duck添加了fly方法如下：</p>
<p><img src="http://img.blog.csdn.net/20150321105123154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjMwOTI2Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//定义鸭子叫</span></div><div class="line">        System.out.println(<span class="string">"quack!quack!"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//定义鸭子游泳</span></div><div class="line">        System.out.println(<span class="string">"duck swiming!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flfly</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//定义鸭子飞</span></div><div class="line">        System.out.println(<span class="string">"duck flying!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//定义鸭子的外观，因为不同鸭子的外观不同，因此定义为抽象方法，让子类去重写</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">diplay</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//其他子类继承Duck</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>正当你为自己的速度感到相当有成就感的时候，产品经理黑着脸过来，“为什么玩具鸭子也会飞啊！”。。(这里是因为后来添加了一个玩具鸭子类，继承于你写的基类Duck，并不怪你，需求改变了。。。)</p>
<p>但聪明的你很快想到了面向对象的方法覆盖，把不会飞的鸭子的fly方法重写一下不就行了。</p>
<p>但是产品经理又一次黑着脸。。“如果以后添加很多鸭子，有些不会飞，有些不会叫，有些都不会，你倒一个个给我改试试看！？”。。。(对产品经理无语，你刚开始说不是鸭子都会飞，都会叫的嘛。。。。。。，但你身为一个苦逼的程序猿，必须改改改)</p>
<p>这时你意识到，需要一个更清晰的方法让鸭子指定可以飞或者可以叫。</p>
<p>不是有接口么？让会飞的实现飞的接口，会叫的实现叫的接口不就行了？</p>
<p><img src="http://img.blog.csdn.net/20150321110236139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjMwOTI2Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>这时黑着脸的产品经理再次出现。。“你这样重复代码不得很多么？！以后要改某些鸭子的飞行行为不是得一个个改？！”。。(挨千刀的产品经理。。。。。，谁让你乱改需求的，一会这个鸭子飞慢点，一会这个鸭子飞快点，一会儿这些鸭子不飞了，但是身为受人尊敬的程序猿，你怎么能在产品经理面前低头呢，于是你说好（妈）办（的）！)</p>
<p>于是你去深山中拜访大师，大师就吐了一句话：“<strong>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</strong>”。</p>
<p>大师一语惊醒梦中人，于是你很快想到：为了要分开“变化和不会变化的部分”，我们准备建立<strong>两组类</strong>（完全远离Duck类），一个是“fly”相关的，一个是“quack”相关的，每一组类将实现各自的动作。比方说，我们可能有一个类实现“呱呱叫”，另一个类实现“吱吱叫”，还有一个类实现“安静”。我们知道Duck类内的fly()和quack()会随着鸭子的不同而改变。为了要把这两个行为从Duck类中分开，我们将把它们从Duck类中取出来，建立一组新类来代表每个行为。</p>
<p>那如何设计那组实现飞行和呱呱叫的行为的类呢？你想不懂，于是打了个电话给山林中的大师，深沉的大师又只说了一句：“<strong>针对接口编程，而不是针对实现编程</strong>。“</p>
<p>你果然聪明人，一点就破，立刻想出如下方法：</p>
<p>从现在开始，鸭子的行为将被放在分开的类中，此类专门提供某行为接口的实现。</p>
<p>这样，鸭子类就不再需要知道行为的实现细节。在新设计中，鸭子的子类将使用接口（FlyBehavior与QuackBehavior）所表示的行为，所以实际的“实现”不会被绑死在鸭子的子类中。像这样：</p>
<p><img src="http://img.blog.csdn.net/20150321111809177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjMwOTI2Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img">其实“针对接口编程”真正的意思是“针对超类型（supertype）编程”。这里所谓的“接口”有多个含义，接口是一个“概念”,“针对接口编程”，关键就在多态。利用多态，针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在具体的行为上。</p>
<p>你有很快懂了。你这么做：</p>
<p><img src="http://img.blog.csdn.net/20150321112834338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjMwOTI2Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>根据以上分析，于是你一鼓作气写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//基类Duck</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Duck&#123;</div><div class="line">    FlyBehavior flyBehavior;</div><div class="line">    QuackBehavior quackBehavior;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span></span>&#123;</div><div class="line">        quackBehavior.quack();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span></span>&#123;</div><div class="line">        flyBehavior.flfly();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"duck swiming"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.flyBehavior = fb;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.quackBehavior = qb;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//fly,duck接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flfly</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//飞行的具体实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flfly</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Duck flying with wings"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyNoway</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flfly</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Duck can't fly"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//叫的具体实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"quack,quack!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I can't quack"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">....</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiniDuck</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.flyBehavior = <span class="keyword">new</span> FlyWithWings();</div><div class="line">        <span class="keyword">this</span>.quackBehavior = <span class="keyword">new</span> CommonQuack();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I am a mini duck"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//客户端调用代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Duck miniDuck = <span class="keyword">new</span> MiniDuck();</div><div class="line">        miniduck.performQuack();<span class="comment">//输出"quack,quack"</span></div><div class="line">        miniDuck.periformFly();<span class="comment">//输入“Duck fly with wings"</span></div><div class="line">        <span class="comment">//突然产品经理说，现在所有的miniduck不能飞了</span></div><div class="line">        miniDuck.setFlyBehavior(<span class="keyword">new</span> FlyNoway());<span class="comment">//现在所有的鸭子都不能飞了，这样就实现了动态的改变鸭                                                 // 子的各种行为了</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>策略模式定义了算法族(每一算法族代表一种接口的一组具体实现类)，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。（书上定义）</p>
<p>自己的理解：</p>
<p>策略模式的核心是要把频繁发生变化的部分封装起来，作用是把变化部分的影响隔离开，避免局部的变化对其它不变化部分造成影响，设计时可能需要更多的时间，但便于维护、复用与扩展。例如本例子中，Duck的fly行为和quack行为会经常性变化，那么就需要把这两种行为封装起来，做成独立的两组实现类，这两组实现类为了能够统一的调用，因此这两组类都是两个统一接口的具体实现，这样，鸭子的fly行为和quack行为就是抽象的，具体拥有何种行为则可以通过传入具体类的对象来动态修改。如果又增加了其他可变的方法，只需在基类中再定义一个类似的接口就行了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式用一句话概括就是&lt;strong&gt;“面向接口编程”&lt;/strong&gt;，将频繁发生变化的方法封装为接口，实现抽象方法与具体对象的解耦，增加了程序的灵活性和可扩展性。&lt;/p&gt;
&lt;p&gt;借用《Head First 设计模式》这本书的例子，说明策略模式提出的背景：&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="设计模式" scheme="http://liuguochao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://liuguochao.github.io/2017/03/20/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuguochao.github.io/2017/03/20/Java单例模式/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T11:38:58.245Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是面试最常问的设计模式之一，在实践中也经常使用，而且也是唯一一个能够用短短几十行代码就可以完整实现的模式，因此经常会被要求在面试中现场写一个单例模式。</p>
<p>实现单例模式的方式有很多，总结一个基本上有以下几类：</p>
<pre><code>1. 饿汉式
2. 懒汉式
3. 枚举模式
</code></pre><p>首先最基本的肯定是将构造函数设为私有，在此基础上几种写法各有特点，主要是因为三个性能指标的影响：</p>
<ol>
<li>lazy loading</li>
<li>执行效率</li>
<li>线程安全</li>
<li>序列化攻击</li>
</ol>
<h4 id="懒汉式-不可用"><a href="#懒汉式-不可用" class="headerlink" title="懒汉式[不可用]"></a>懒汉式[不可用]</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</div><div class="line">            singleton=<span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在单线程的情况下，该单例模式能够很好的使用，但是如果使用多线程，线程1和线程2同时访问到判断实例是否为空的if语句，则这两个线程都会创建一个实例，此时该种单例模式失效。</p>
<p>优点：实现了Lazy Loading，第一次使用的时候才真正实例化</p>
<p>缺点：无法保证线程安全</p>
<h4 id="懒汉式改进-双重检查（还是不安全）"><a href="#懒汉式改进-双重检查（还是不安全）" class="headerlink" title="懒汉式改进-双重检查（还是不安全）"></a>懒汉式改进-双重检查（还是不安全）</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;<span class="comment">//1</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">//2</span></div><div class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;<span class="comment">//3</span></div><div class="line">                    singleton=<span class="keyword">new</span> Singleton();<span class="comment">//4</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比懒汉式，加了一个同步锁，而且将singleton声明为volatile，使得线程之间对singleton的读写可见，这样就实现了多线程下单例模式的安全性。</p>
<p>据同学面试小米，面试官指出：<strong>即使是双重检测，也还是无法保证线程安全。</strong></p>
<p>比如下面这种情况：</p>
<ol>
<li>步骤1中线程1检测到singleton为null，于是进入步骤2获取锁，到步骤4中，开始实例化一个实例。</li>
<li>这里问题出来了，在实例化的过程中，执行构造方法之前，singleton就已经是非null的了</li>
<li>这个时候如果线程2执行到步骤1，检测到singleton为非null，那么就直接返回这个对象了，这个对象有可能还并没有执行构造函数，也就是说这里检测singleton是否为null，只能保证是否有这个实例了，但是却没法保证这个实例的构造过程是否已经完全执行完毕。此时这个实例就是失效的</li>
</ol>
<p>这里涉及到JVM的一个无序写入的问题，即在Java 编译器中，Singleton 类的初始化与instance变量赋值的顺序不可预料。 如：假设线程1执行到 instance = new Singleton();这一句，但又未完成初始化时，被线程抢夺掉时间片，这时线程2判断了instance非空并返回一个instance对象， 但好可惜，这只是一个未完成初始化的半成品！这个半成品的成员很可能是失效的。</p>
<p>但是，在JDK1.5以前，是存在这样的问题的，在JDK1.5之后该问题已经不存在了。</p>
<h4 id="饿汉式-可用"><a href="#饿汉式-可用" class="headerlink" title="饿汉式[可用]"></a>饿汉式[可用]</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>优点：这种写法的优点就是线程安全，利用类加载机制避免了多线程问题</li>
<li>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</li>
</ul>
<h4 id="饿汉式改进-静态内部类"><a href="#饿汉式改进-静态内部类" class="headerlink" title="饿汉式改进-静态内部类"></a>饿汉式改进-静态内部类</h4><p>饿汉式主要缺点就是无法实现Lazy Loading，可以通过静态内部类来解决这一问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与上面的直接定义final实例不同的是定义一个静态的内部类，在内部类中持有这个实例，这样只有在第一次获取实例的时候才会加载这个内部类，从而实现Lazy Loading。</p>
<h4 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h4><p>用双重检查检查或者静态内部类的改进写法既实现了lazy loading也保证了线程安全，但是单例模式还会面临一个问题就是序列化，于是就有了枚举类型的单例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singleton.IINSTANCE.getInstance();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">        IINSTANCE;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> EnumSingleton singleton;        </div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">            singleton=<span class="keyword">new</span> EnumSingleton();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> singleton;</div><div class="line">        &#125;        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        EnumSingleton a=EnumSingleton.getInstance();</div><div class="line">        EnumSingleton b=EnumSingleton.getInstance();</div><div class="line">        System.out.println(a==b);<span class="comment">//true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>《Effective Java》认为用枚举实现的单例模式是最佳方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是面试最常问的设计模式之一，在实践中也经常使用，而且也是唯一一个能够用短短几十行代码就可以完整实现的模式，因此经常会被要求在面试中现场写一个单例模式。&lt;/p&gt;
&lt;p&gt;实现单例模式的方式有很多，总结一个基本上有以下几类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 饿汉式
2
    
    </summary>
    
    
      <category term="设计模式" scheme="http://liuguochao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://liuguochao.github.io/2017/03/20/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuguochao.github.io/2017/03/20/Java工厂模式/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T12:37:34.314Z</updated>
    
    <content type="html"><![CDATA[<p>一般认为工厂模式分为简单工厂模式、工厂方法模式、抽象工厂模式，但严格来说，简单工厂模式并不属于设计模式，而更像是一种编程习惯。下面介绍这3种设计模式：</p>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//假如你经营一个Pizza店,下面是你的Pizza店订购系统的代码</span></div><div class="line"><span class="function">Pizza <span class="title">orderPizza</span><span class="params">()</span></span>&#123;</div><div class="line">	Pizza pizza = <span class="keyword">new</span> Pizza();</div><div class="line">  	<span class="comment">//以下是pizza订购的一些共同操作</span></div><div class="line">	pizza.preprare();</div><div class="line">	pizza.bake();</div><div class="line">	pizza.cut();</div><div class="line">	pizza.box();</div><div class="line">	<span class="keyword">return</span> pizza;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上只是针对一种pizza，如果客户订购不同种类的Pizza，则该段代码应改写如下<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">	Pizza pizza;</div><div class="line">	<span class="comment">//.................................生产Pizza</span></div><div class="line">	<span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>))&#123;</div><div class="line">		pizza = <span class="keyword">new</span> CheesePizza();</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"greek"</span>))&#123;</div><div class="line">		pizza = <span class="keyword">new</span> GreekPizza();</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>))&#123;</div><div class="line">		pizza = <span class="keyword">new</span> PepperoniPizza();</div><div class="line">	&#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//.................................</span></div><div class="line">	pizza.preprare();</div><div class="line">	pizza.bake();</div><div class="line">	pizza.cut();</div><div class="line">	pizza.box();</div><div class="line">	<span class="keyword">return</span> pizza;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于竞争激烈，你不断增加Pizza的种类，删除Pizza种类，因此，你需要不断的添加，修改else if，但是pizza的准备、烘烤、包装等操作都是保持不变的，因此我们需要将生产Pizza的代码抽离出来，这样就满足了代码设计的基本原则<br>既然需要生产不同种类的Pizza，因此可以创造一个生产Pizza的工厂类，根据订单的需要，生产不同的Pizza</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">simplePizzaFactory</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">		Pizza pizza = <span class="keyword">null</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> CheesePizza();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"greek"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> GreekPizza();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> PepperoniPizza();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能会问，这不就是转移封装了一下代码吗？有何意思。当然不是，因为SimplePizzaFactory可以有很多客户，而且以后扩展披萨种类就不用修改到订购的代码了，OrderPizza所要知道的是它拥有一个工厂，该工厂可以生产它所要的 Pizaa。它甚至不需要知道做出来的披萨的样子，就可以去prepare，去bake了。</p>
<p>这就是所谓的简单工厂模式，用简单工厂模式改写orderPizaa，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">	SimplePizzaFactory factory;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.factory = factory;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">		Pizza pizza;</div><div class="line">		</div><div class="line">		pizza = factory.createPizza(type)</div><div class="line">		</div><div class="line">		pizza.preprare();</div><div class="line">		pizza.bake();</div><div class="line">		pizza.cut();</div><div class="line">		pizza.box();</div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单工厂模式更一般的写法是，首先定义一组接口或者抽象类（如创建一个Pizza的接口，定义Pizza的一些共有属性），然后创建继承于该接口的各种实现类（例如本文中的各种cheese披萨，greek披萨等），最后定义一个工厂类，该工厂类可以根据传入参数的不同创建不同的类对象，但是工厂类的返回对象类型必须是定义的接口或者抽象类，这样在以后利用的过程中，代码弹性比较大，不用做很大程度的修改，即面向接口编程。相应的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>&#123;</div><div class="line">	<span class="comment">//这是一个Pizza,定义了Pizza共有的属性和方法</span></div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> CheesePizza extends Pizza&#123;</div><div class="line">	<span class="comment">//这是一个具体的Pizza类-CheesePizza</span></div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> GreekPizza extends Pizza&#123;</div><div class="line">	<span class="comment">//这是一个具体的Pizza类-GreekPizza</span></div><div class="line">		...</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">simplePizzaFactory</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">		Pizza pizza = <span class="keyword">null</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> CheesePizza();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"greek"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> GreekPizza();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> PepperoniPizza();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">	SimplePizzaFactory factory;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.factory = factory;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">		Pizza pizza;</div><div class="line">		</div><div class="line">		pizza = factory.createPizza(type)</div><div class="line">		</div><div class="line">		pizza.preprare();</div><div class="line">		pizza.bake();</div><div class="line">		pizza.cut();</div><div class="line">		pizza.box();</div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>现在你要开连锁店了，不同地区的连锁店有不同的风味，你有一个想法，创建不同的工厂，比如纽约工厂和芝加哥工厂，然后像之前的代码一样将他们传入PizzaStore中，就可以生产出具有独特地域风格的Pizza了，类似修改为这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaFactory</span> <span class="keyword">extends</span> <span class="title">SimpleFactory</span></span>&#123;</div><div class="line">  <span class="comment">//加入自己的纽约风味制作方法</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaFactory</span> <span class="keyword">extends</span> <span class="title">SimpleFactory</span></span>&#123;</div><div class="line">  <span class="comment">//加入自己的芝加哥风味制造方法</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">....</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">  <span class="comment">//相应的代码不用改变</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用</span></div><div class="line">NYPizzaFactory nyFactory = <span class="keyword">new</span> NYPizzaFactory();</div><div class="line">PizzaStore nyStore = <span class="keyword">new</span> PizzaStore(nyFactory);</div><div class="line">nyStore.orderPizza(<span class="string">"Cheese"</span>);</div><div class="line"></div><div class="line">ChicagoPizzaFactory chicagoFactory = <span class="keyword">new</span> ChicagoPizzaFactory();</div><div class="line">PizzaStore chicagoStore = <span class="keyword">new</span> PizzaStore(chicagoFactory);</div><div class="line">chicagoStore.orderPizza(<span class="string">"Cheese"</span>);</div></pre></td></tr></table></figure>
<p>上文可以很好的解决了不同地区加盟店Pizza的生产问题，但是你会发现如果传错工厂可能出现纽约连锁店制作出芝加哥风味的比萨（例如你在纽约连锁店订购了一个cheese味道的Pizza，但是系统错误地将芝加哥工厂的对象传给了纽约连锁店的订购系统，就乱了……）；此时就不能通过这种增开分厂的方式解决了。还是需要将店铺和生产相结合，但是你又想保持你的烘烤方法，切片，包装等不变。</p>
<p>此时，可以将PizzaStore（总店）声明为抽象类，让各个地区的分店去继承总店，同时将生产Pizza的方法移回PizzaStore，但是将其声明为一个抽象方法，让各个分店去继承，每个店铺自己去实现具体的生产细节，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">		Pizza pizza;</div><div class="line">		</div><div class="line">		pizza = createPizza(type)</div><div class="line">		</div><div class="line">		pizza.preprare();</div><div class="line">		pizza.bake();</div><div class="line">		pizza.cut();</div><div class="line">		pizza.box();</div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">  	<span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> NYCheesePizza();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"greek"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> NYGreekPizza();</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> NYPepperoniPizza();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">  	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//类似芝加哥的也这么写</span></div><div class="line">......</div><div class="line"><span class="comment">//使用</span></div><div class="line">PizzaStore nyStore = <span class="keyword">new</span> PizzaStore();</div><div class="line">nyStore.orderPizza(<span class="string">"Cheese"</span>);</div><div class="line"></div><div class="line">PizzaStore chicagoStore = <span class="keyword">new</span> PizzaStore(chicagoFactory);</div><div class="line">chicagoStore.orderPizza(<span class="string">"Cheese"</span>);</div></pre></td></tr></table></figure>
<p>相比之前的简单工厂模式，这个货真价实的工厂模式的优点：</p>
<ul>
<li>同样实现了new对象的具体过程与对象行为的分离，但不同的是我们是利用继承（扩展）来实现的，也就是“<strong>下放</strong>”（把具体实现放到更低的类层次上）</li>
<li>每一个具体Store都必须实现自己的Create细节，但同时又可以利用基类Store的制作工艺（bake()方法等等）</li>
<li>一个抽象的工厂方法轻松实现了工厂模式（甚至Factory自始至终根本没有出现，但我们确实已经实现了“工厂”，不是吗？）</li>
</ul>
<p>工厂方法模式的定义：定义了一个创建对象的抽象类或者接口，但是由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>考虑一下这种情况，你开了很多的连锁店，因为大家都是继承于你的总店，因此生产制作Pizza的步骤都是一样的，你认为这样就万无一失了。但是有的店为了降低成本增加盈利，使用不合格的Pizza制作原料，导致你的Pizza品牌受到了影响。</p>
<p>你想，可以通过建立统一的Pizza原料生产工厂解决原材料的质量问题。解决步骤如下：</p>
<ol>
<li>为每个区域创建一个工厂类，工厂可以生产一组该区域所需要的原材料</li>
<li>实现一组原材料类供工厂使用，保证原材料质量的统一性</li>
<li>将新的原料工厂类整合到原来的PizzaStore类中</li>
</ol>
<p>定义一个原料工厂的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">CreateSauce</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>各个地方的原料工厂继承这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> <span class="title">implents</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThinCrustDough();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MarinaraSauce();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReggianoCheese();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相应的改写NYPIzzaStore类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">publci <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">  	</div><div class="line">  	<span class="meta">@Override</span></div><div class="line">  	<span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">        Pizza pizza = <span class="keyword">null</span>;</div><div class="line">        PizzaIngredientFactory nyPizzaIngredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</div><div class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> NYCheesePizza(nyPizzaIngredientFactory);<span class="comment">//这里省略了修改Pizza类的构造方法</span></div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"greek"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> NYGreekPizza(nyPizzaIngredientFactory);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>))&#123;</div><div class="line">			pizza = <span class="keyword">new</span> NYPepperoniPizza(nyPizzaIngredientFactory);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">  	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可知，抽象工厂模式是对工厂方法模式的扩展，它定义了一个接口，用于创建相关或依赖对象的<strong>家族</strong>，而不需要指明具体类。</p>
<p>工厂方法和抽象工厂有太多的相似，对比下二者的特点：</p>
<p>工厂方法的最大特点在于工厂接口只有一个工厂方法，具体产品的创建延迟到子类实现，客户端只需要知道获取了一个工厂对象，具体产品并不知道，实现客户端和具体产品的解耦。而抽象工厂可以看做是工厂方法的升级版本，因为工厂方法可以看做生产一个产品等级的，抽象工厂则是生产不同产品等级的相关联的系列产品。但是正因为此，抽象工厂的缺点在于当向系列产品添加新的产品要修改抽象工厂的方法，这违背开放–关闭原则的，而工厂方法若是添加新的产品只要扩展新的工厂类就可以了，在实际开发中，工厂方法的应用更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般认为工厂模式分为简单工厂模式、工厂方法模式、抽象工厂模式，但严格来说，简单工厂模式并不属于设计模式，而更像是一种编程习惯。下面介绍这3种设计模式：&lt;/p&gt;
&lt;h4 id=&quot;简单工厂模式&quot;&gt;&lt;a href=&quot;#简单工厂模式&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="设计模式" scheme="http://liuguochao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://liuguochao.github.io/2017/03/20/Java%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuguochao.github.io/2017/03/20/Java观察者模式/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T11:37:08.352Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式又叫发布-订阅模式，来源于现实世界中报纸与订阅者之间关系的抽象，一种报纸对应多个订阅者，订阅者可以随时解除订阅，未订阅的读者也可以随时开始订阅。一旦有新报纸发布，所有的订阅者都会收到新内容。它可以很好的维护对象之间“一对多”的依赖关系，因此经常在实践中得以运用，也经常会在面试中问道。</p>
<p>观察者模式结构图：</p>
<p><img src="./observer.jpg" alt="observer"></p>
<p>下面就结合报纸订阅这一现实场景，实现观察者模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//定义抽象主题</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//定义抽象观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object[] args)</span></span>;<span class="comment">//args是通知要修改的内容</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//实现具体主题</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>&#123;</div><div class="line">        list.add(observer);</div><div class="line">        System.out.println(<span class="string">"Register an observer!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (list.indexOf(observer) &gt; <span class="number">0</span>)&#123;</div><div class="line">            list.remove(observer);</div><div class="line">            System.out.println(<span class="string">"Remove an observer"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">(Object[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer observer : list)&#123;</div><div class="line">            observer.update(args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Object[] newArgs)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"The state changed: "</span>  + newArgs);</div><div class="line">        <span class="keyword">this</span>.notifyObserver(newArgs);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实现具体观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Object arg1;</div><div class="line">    <span class="keyword">private</span> Object arg2;</div><div class="line">    ...</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.setArg1(args[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">this</span> .setArg2(args[<span class="number">1</span>]);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试代码（客户端代码）</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</div><div class="line">        Subject subject = <span class="keyword">new</span> ConcreteSubject();</div><div class="line">        Observer observer1 = <span class="keyword">new</span> ConcreteObserver();</div><div class="line">        Observer observer2 = <span class="keyword">new</span> ConcreteObserver();</div><div class="line">        Observer observer3 = <span class="keyword">new</span> ConcreteObserver();</div><div class="line">        <span class="comment">//observer1,observer2对该报纸感兴趣，observer3对其不感兴趣</span></div><div class="line">        subject.registerObserver(observer1);</div><div class="line">        subject.registerObserver(observer2);</div><div class="line">        subject.change(Object someGoodNews);</div><div class="line">        <span class="comment">//observer1对该报纸失望，取消订阅，observer3对其感兴趣并订阅</span></div><div class="line">        subject.removeObserver(observer1);</div><div class="line">        subject.registerObserver(observer3);</div><div class="line">        ....<span class="comment">//一直进行下去</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样观察者模式就实现了主题和观察者之间松耦合，它们可以交互，但是却不太清楚彼此的细节，有新类型的观察者出现时，主题的代码不需要修改，主题可以实时的添加和删除观察者。此时对象之间的依赖关系为：</p>
<p><img src="./yilai.png" alt="yilai"></p>
<p>如果不用观察者模式，相应的代码书写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Observer[] observers;<span class="comment">//变化的地方</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Object[] someGoodNews)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer observer : observers)&#123;</div><div class="line">            observer.update(someGoodnews);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然这种写法比较简单，但是一旦创建了subject，就不能动态的添加和删除observer了，如果想要添加或删除，就必须修改subject代码，这违反了软件设计的“开放-关闭”原则。如果我们将<strong>变化</strong>的地方抽出来，就可以很好的解决主题和观察者之间相互依赖的关系了。将主题只定义为内容的提供者，观察者只定义为内容的获取者，二者通过notify方法相连接，就把二者的强耦合，变为了弱耦合。</p>
<p>因为观察者模式太常用了，因此jdk就提供了一套实现观察者模式的类和接口。在java.util包里，有java.util.Observable类和java.util.Observer接口。其中Observable是被观察者，Observer是观察者。</p>
<p>相应的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</div><div class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用jdk自带的类和接口实现一个观察者模式例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//假设需要监控某一商品的名字和价格变化，这里设计该商品为被观察者，价格和名字为观察者，相应的代码书写如下</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">product</span> <span class="keyword">extends</span> <span class="title">Obserable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        setChanged();</div><div class="line">        notifyObservers(name);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> price;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">        setChanged();</div><div class="line">        notifyObservers();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observalbe observable, Object arg)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> String)&#123;</div><div class="line">            System.out.print(<span class="string">"The product name "</span> + name + <span class="string">"--&gt;"</span>)</div><div class="line">            <span class="keyword">this</span>.name = (String) arg;</div><div class="line">            System.out.print(name + <span class="string">"\n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price = <span class="number">0.0</span>;</div><div class="line">  	</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object arg)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Double)&#123;</div><div class="line">            System.out.print(<span class="string">"The product price "</span> + price + <span class="string">"--&gt;"</span>)</div><div class="line">            <span class="keyword">this</span>.price = (<span class="keyword">double</span>) arg;</div><div class="line">            System.out.print(price + <span class="string">"\n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察者模式又叫发布-订阅模式，来源于现实世界中报纸与订阅者之间关系的抽象，一种报纸对应多个订阅者，订阅者可以随时解除订阅，未订阅的读者也可以随时开始订阅。一旦有新报纸发布，所有的订阅者都会收到新内容。它可以很好的维护对象之间“一对多”的依赖关系，因此经常在实践中得以运用，也
    
    </summary>
    
    
      <category term="设计模式" scheme="http://liuguochao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello My Blog</title>
    <link href="http://liuguochao.github.io/2017/03/20/helloMyBlog/"/>
    <id>http://liuguochao.github.io/2017/03/20/helloMyBlog/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T11:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<p>今天搭建了我的博客。</p>
<p>其实很久之前，舍友就推荐我搭建个自己的博客，说是很好玩，博客的主题也都很fashion，但是都忘记了。现在，研究生也都读了一半了，想想自己学习的东西大都糊里糊涂地记在脑海里，没有形成系统，这样在整理自己的知识网络的过程中，难免会有所遗漏。</p>
<p>因此，今天费了一下午的时间，按照这个<a href="http://blog.csdn.net/jzooo/article/details/46781805" target="_blank" rel="external">教程</a>，就搭建了自己的一个博客，希望以后没事的时候，可以在此地，记录一下平淡生活中的一些值得再看的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天搭建了我的博客。&lt;/p&gt;
&lt;p&gt;其实很久之前，舍友就推荐我搭建个自己的博客，说是很好玩，博客的主题也都很fashion，但是都忘记了。现在，研究生也都读了一半了，想想自己学习的东西大都糊里糊涂地记在脑海里，没有形成系统，这样在整理自己的知识网络的过程中，难免会有所遗漏。
    
    </summary>
    
    
      <category term="碎碎念" scheme="http://liuguochao.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://liuguochao.github.io/2017/03/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://liuguochao.github.io/2017/03/20/数据库事务面试准备/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T12:33:24.957Z</updated>
    
    <content type="html"><![CDATA[<p>事务定义了一组操作，这些操作需满足，要么全部执行成功，要么全部不执行，它是数据库维持一致性的基本单位</p>
<h4 id="数据库事务的4个基本属性"><a href="#数据库事务的4个基本属性" class="headerlink" title="数据库事务的4个基本属性"></a>数据库事务的4个基本属性</h4><ol>
<li><p>原子性</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，一般通过<strong>预写日志</strong>的方法进行实现。</p>
<p>将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过<strong>回溯日志</strong>，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash<br>recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
<p><strong>原子性并不能完全保证数据库的一致性</strong>。例如，事务1需要将100元转入账户A，先读取账号A的值，然后在这个值上加上100；但是，在这两个操作之间，另一个事务2也修改了账户A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，账户A只增加了100元，因此事务2的修改结果被事务1覆盖掉了。（<strong>丢失更新</strong>）</p>
</li>
<li><p>一致性</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p><strong>一致性是数据库最基本的属性，其他的3个属性都是为了保证数据库的一致性而存在的</strong>。</p>
</li>
<li><p>隔离性</p>
<p>隔离性是指多个并发事务之间要相互隔离，以保证数据库操作后的一致性。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p><strong>为了实现隔离性，则需要对线程操作的数据库对象加锁</strong>：</p>
<ol>
<li>一种是悲观锁，即对当前事务操作所涉及到的对象都加锁，操作完成后再其释放给其他事务操作。为了尽可能地提高性能，发明了各种粒度（数据库级/表级/行级……）/各种性质（共享锁/排它锁/共享意向锁……）的锁。为了解决死锁问题，又发明了两阶段锁协议/死锁检测等一系列的技术。</li>
<li>一种是乐观锁，即不同事务可以看到同一对象（一般是数据行）的不同历史版本。如果有两个事务同时修改了同一数据行，那么在较晚的事务提交时进行冲突检测。实现也有两种，一种是通过日志Undo的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历史版本，通过时间戳来区分。</li>
</ol>
</li>
<li><p>持久性</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p><strong>持久性的保证也可以通过预写日志的方式来实现</strong>（例如SQL Server就是通过write-ahead transaction log来实现的）</p>
</li>
</ol>
<h4 id="数据库事务并行时会遇到的一些问题"><a href="#数据库事务并行时会遇到的一些问题" class="headerlink" title="数据库事务并行时会遇到的一些问题"></a>数据库事务并行时会遇到的一些问题</h4><ol>
<li><p>脏读</p>
<p>脏读意味着一个事务读取了另一个事务未提交的数据</p>
<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money+<span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’B’;  (此时A通知B)</div><div class="line"></div><div class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money - <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’A’;</div></pre></td></tr></table></figure>
<p>　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
</li>
<li><p>不可重复读</p>
<p>不可重复读是指在对于数据库中的某个数据，<strong>一个事务范围内</strong>多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>不可重复读和脏读的区别是，<strong>脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</strong></p>
<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如用户A和用户B对于同一个数据依次查询，但是结果不同，那么A和B就可能会怀疑数据库的记录。</p>
</li>
<li><p>幻读</p>
<p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p><strong>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体</strong>（比如数据的个数）。</p>
</li>
<li><p>丢失更新</p>
<p>两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。</p>
</li>
</ol>
<h4 id="数据库事务的隔离级别"><a href="#数据库事务的隔离级别" class="headerlink" title="数据库事务的隔离级别"></a>数据库事务的隔离级别</h4><p>​       为了解决上面由于事务并行时，没有相互隔离导致的一些数据库不一致的问题，可以通过引入不同的事务隔离机制来防止以上问题的发生。不同的事务隔离机制对应着不同的数据库对象加锁机制，隔离级别越高，并行性能越低，但数据库一致性越高。</p>
<ol>
<li><p>读未提交（Read Uncommited）</p>
<p>在事务开始的时候可以给要准备写操作的这一行数据加一个排它锁，如果是读操作，就给该行数据一个<strong>读锁</strong>。这样之后，在修改该行数据的时候，不让其他进程对该行数据有任何操作。而读该行数据的时候，其他进程不能更改，但可以读。读或写完成时，释放锁，最后commit提交。这时候<strong>读写就分离开了，写和写也就分离开了</strong>。注意：此时加锁和释放锁的过程由mysql数据库自身来维护，不需要我们人为干涉，这是数据库事务的最低隔离级别。</p>
<p><strong>这种隔离级别无法解决脏读的问题</strong>，也就无法解决后面更复杂的问题。</p>
<p>例如，事务T1更改数据库中的一行记录，修改完之后释放锁，这时候另一个事务T2读取了该数据，此时先前的事务T1是还未提交的，T1回滚数据，则T2读取到的数据就变成了无用的或者是错误的数据。即发生了脏读。虽然对读写的操作都是独立的，但是无法解决事务之间数据的同步问题。</p>
</li>
<li><p>读已提交（Read Commited）</p>
<p>将读未提交的锁机制进行调整，读数据或者修改数据后，锁不马上进行释放，直到该事务完成提交后再进行释放，此时在事务提交前，其他事务是无法对该行数据进行读取或者修改的操作的，因此，以后的事务读到的数据都是前一个事务已经提交的数据，因此，该隔离级别称为读已提交。<strong>它可以防止脏读的发生，但是无法规避不可重复读问题的发生。</strong>（应用的是行锁）</p>
<p>如果真的是读数据或者写数据，在事务提交完成前不释放锁的话，不可重复读是不可能发生的，但是为什么不可重复读能够发生，那是因为mysql使用了一个并发版本控制机制，他们把它叫做MVCC，通俗的也就是说：mysql为了提高系统的并发量，在事务未提交前，虽然事务内操作的数据是锁定状态，但是另一个事务仍然可以读取，大多数数据库默认的就是这个级别的隔离性，但mysql不是。因此会出现不可重复读的问题。</p>
<p>诚然，行锁也么办法解决幻读的发生，因为虽然锁住了正在操作的数据行，但是它仍然阻止不了另一个事务往表里插入新的数据，因此幻读此时也会发生。</p>
</li>
<li><p>可重复读（Repeatable Read）</p>
<p>mysql依然采取的是MVCC并发版本控制来解决不可重复读的问题，具体是：如果事务中存在多次读取同样的数据，MySQL第一次读的时候仍然会保持选择读最新提交事务的数据，当第一次之后，之后再读时，mysql会取第一次读取的数据作为结果。这样就保证了同一个事务多次读取数据时数据的一致性。该隔离级别是MySql默认的隔离级别。</p>
</li>
<li><p>串行化（Serializable）</p>
<p>应用表锁的机制，在一个事务操作表的时候，锁住整个表格，直到该事务执行完毕，才释放表资源给下一个事务，因此所谓的脏读，不可重复读，幻读，丢失更新的问题，都不可能发生，但是事务之间并行的效率也是最低的。</p>
</li>
</ol>
<h4 id="数据库事务的SQL操作"><a href="#数据库事务的SQL操作" class="headerlink" title="数据库事务的SQL操作"></a>数据库事务的SQL操作</h4><ol>
<li>查看MySql数据库中当前事务的隔离级别：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> @@[<span class="keyword">global</span>|<span class="keyword">session</span>].tx_isolation</div></pre></td></tr></table></figure>
<ol>
<li><p>修改MySql数据库事务的隔离级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">set</span> [<span class="keyword">global</span>|<span class="keyword">session</span>] <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名称</div><div class="line">或</div><div class="line"><span class="keyword">set</span> tx_isolation = <span class="string">'隔离级别名称'</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">........(sql 语句)</div><div class="line">if (error)</div><div class="line">    <span class="keyword">rollback</span>;</div><div class="line"><span class="keyword">commit</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Java中如何应用事务"><a href="#Java中如何应用事务" class="headerlink" title="Java中如何应用事务"></a>Java中如何应用事务</h4><ol>
<li><p>在java中，我们通过调用jdbc的api来应用事务，jdbc api默认的情况为自动提交事务，也就是说，每一条对数据库更新的sql语句代表一项事务，操作成功后，系统自动调用commit()来提交，否则将调用rollback()来撤消事务。 而我们如果想要将多条语句看成一个事务的话，应该首先关闭自动提交，可以通过调用JDBC自带的setAutoCommit(false)方法来实现。</p>
</li>
<li><p>以下是java中事务处理的一般方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> sID)</span> </span>&#123; </div><div class="line">　 dbc = <span class="keyword">new</span> DataBaseConnection(); </div><div class="line">　 Connection con = dbc.getConnection(); </div><div class="line">　 <span class="keyword">try</span> &#123; </div><div class="line">　　 con.setAutoCommit(<span class="keyword">false</span>);<span class="comment">// 更改JDBC事务的默认提交方式 </span></div><div class="line">　　 dbc.executeUpdate(<span class="string">"delete from xiao where ID="</span> + sID); </div><div class="line">　　 dbc.executeUpdate(<span class="string">"delete from xiao_content where ID="</span> + sID); </div><div class="line">　　 dbc.executeUpdate(<span class="string">"delete from xiao_affix where bylawid="</span> + sID); </div><div class="line">　　 con.commit();<span class="comment">//提交JDBC事务 </span></div><div class="line">　　 con.setAutoCommit(<span class="keyword">true</span>);<span class="comment">// 恢复JDBC事务的默认提交方式 </span></div><div class="line">　　 dbc.close(); </div><div class="line">　　 <span class="keyword">return</span> <span class="number">1</span>; </div><div class="line">　 &#125; </div><div class="line">　 <span class="keyword">catch</span> (Exception exc) &#123; </div><div class="line">　　 con.rollBack();<span class="comment">//回滚JDBC事务 </span></div><div class="line">　　 exc.printStackTrace(); </div><div class="line">　　 dbc.close(); </div><div class="line">　　 <span class="keyword">return</span> -<span class="number">1</span>; </div><div class="line">　 &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事务定义了一组操作，这些操作需满足，要么全部执行成功，要么全部不执行，它是数据库维持一致性的基本单位&lt;/p&gt;
&lt;h4 id=&quot;数据库事务的4个基本属性&quot;&gt;&lt;a href=&quot;#数据库事务的4个基本属性&quot; class=&quot;headerlink&quot; title=&quot;数据库事务的4个基本
    
    </summary>
    
    
      <category term="数据库" scheme="http://liuguochao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试总结</title>
    <link href="http://liuguochao.github.io/2017/03/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://liuguochao.github.io/2017/03/20/数据库面试题/</id>
    <published>2017-03-20T09:35:58.000Z</published>
    <updated>2017-03-20T12:59:10.566Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>#### </p>
<h5 id="2：应用程序编程优化"><a href="#2：应用程序编程优化" class="headerlink" title="2：应用程序编程优化"></a>2：应用程序编程优化</h5><ol>
<li><p>使用数据库连接池</p>
<p>因为数据库建立连接的代价比较高，因此如果对于数据库的查询查询一次就建立一次连接，会使得服务器的大部分性能消耗在建立连接上。建立数据库连接池，可以很好的解决这个问题，至于框架怎么配置数据库连接池，请百度。</p>
</li>
<li><p>减少对mysql的访问</p>
<ul>
<li><p>避免对同一数据做重复检索</p>
<p>应用中需要理清对数据库的访问逻辑，如果一次连接就能够查询到所要的结果，就不用两次连接，这样就可以大大减少对数据库无畏的访问。</p>
<p>如，在某应用中查询某人的年龄和性别，那么就可以执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> age,gender <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> userid=<span class="number">231</span>;</div></pre></td></tr></table></figure>
<p>之后有需要这个人的家庭住址，又开始执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> address <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> userid=<span class="number">231</span>;</div></pre></td></tr></table></figure>
<p>而这两次请求基本上是同一个业务逻辑，此时就应该将这两次查询合二为一。</p>
</li>
<li><p>使用查询缓存</p>
<p>查询缓存可以存储select查询的文本以及相应的结果。如果随后收到一个相同的查询，服务器会从查询缓存中重新得到查询结果，而不再需要解析和执行查询。</p>
<p>查询缓存的适用对象是更新不频繁的表，当表更改（包括表结构和表数据）后，查询缓存值的相关条目被清空。查询缓存的相关参数主要有一下几个：</p>
<p><img src="H:\面试准备\cache.png" alt="cache"></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>​                     have_query_cache: 表明服务器在安装时是否已经配置了高速缓存</p>
<p>​             query_cache_size:  表明缓存区的大小</p>
<p>​                 query_cache_type: 表明缓存是否开启，0或者off代表关闭，1或者on代表开启，2或者demand代表</p>
<p>​                                                       只有带sql_cache的select语句才能使用缓存</p>
<p>​              如果缓存没有开启，可以配置通过配置mysql中my.cnf文件来开启，具体可如下操作：</p>
<p>​                      1 打开my.cnf文件</p>
<p>​                      2 [mysqld]中添加：</p>
<p>​                        query_cache_size = 20M</p>
<p>​                        query_cache_type = ON</p>
<p>​                      3 重启mysql服务</p>
<p>​                      通过show status语句可以查看当前缓存使用的状态</p>
<p>​                     <img src="H:\面试准备\cache1.png" alt="cache1"></p>
<h4 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h4><p>​    一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头痛的分页场景是“limit 1000,20”,此时mysql排序出前1020条记录后仅仅需要返回第1001到1020条记录，前1000条记录都会被抛弃，查询和排序的代价非常高。</p>
<ol>
<li><p>第一种思路（子查询优化法）</p>
<p>在索引上完成排序分页的操作，最后根据主键关联回原表查询所需要的其他列内容。例如，对电影表film根据标题提了排序后取某一页的数据，直接查询的时候，能够从explain的输出结果中看到优化器实际上做了全表扫描，处理效率不高：</p>
<p><img src="H:\面试准备\page.png" alt="page"></p>
<p>第一个命令是直接查询，可以看出没有用到索引，改进后用了索引，减少了全表扫描，提高了分页查询的效率。</p>
</li>
<li><p>第二种思路</p>
<p>把limit查询转换为某个位置的查询。例如，假设每页10条记录，查询payment中按照租赁编号rental_id逆序排序的第42页记录，能够看到执行计划走了全表扫描</p>
<p><img src="H:\面试准备\page1.png" alt="page1"></p>
<p>和开发人员协商一下，翻页的过程中通过增加一个参数last_page_record，用来记录上一页最后一行的租赁编号rental_id，例如第41页最后一行的租赁编号rental_id=15460:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> payment <span class="keyword">where</span> rental_id &lt; <span class="number">15460</span> <span class="keyword">order</span> <span class="keyword">by</span> rental_id <span class="keyword">desc</span> limt <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>这样，第一页查询比较慢，但其他页的查询将会比较快，而且只适用于排序字段不会出现重复值的特定环境。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;#### &lt;/p&gt;
&lt;h5 id=&quot;2：应用程序编程优化&quot;&gt;&lt;a href=&quot;#2：应用程序编程优化&quot; class=&quot;headerlink&quot; title=&quot;2：应用程序编程优化&quot;&gt;&lt;/a&gt;2：应用程序编程优化&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用数据库连接
    
    </summary>
    
    
      <category term="数据库" scheme="http://liuguochao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
